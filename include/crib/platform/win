
#pragma once

#include <system_error>
#include <vector>


#ifndef UNICODE
#	define UNICODE 1
#endif

#ifndef NOMINMAX
#	define NOMINMAX 1
#endif

#ifndef WIN32_LEAN_AND_MEAN
#	define WIN32_LEAN_AND_MEAN 1
#endif

#include <Windows.h>


namespace crib::platform::win
{

	class initialize_com
	{
	public:
		initialize_com();
		initialize_com(const DWORD concurrency_model);
		~initialize_com();

	private:
		bool must_shutdown;
	};


	class error : public std::system_error
	{
	public:
		error(std::error_code code);
		error(HRESULT code) : error({ code, std::system_category() }) {}
		error(DWORD code) : error(std::error_code(code, std::system_category())) {}
		error() : error(GetLastError()) {}

		const char* what() const noexcept override { return message.c_str(); }

	private:
		std::string message;
	};

	inline void throw_on_error(HRESULT code, const char* hint = nullptr)
	{
		if (FAILED(code))
			throw error(code);
	}

	class wide_string
	{
	public:
		wide_string() : wide_string(1023) {}

		explicit wide_string(const size_t maxStringLength) : utf16(maxStringLength + 1)
		{
			utf16.back() = utf16.front() = 0;
		}

		// access to Windows-style null-terminated UTF-16 string pointer
		operator wchar_t*() { return utf16.data(); }
		operator const wchar_t*() const { return utf16.data(); }

		// capacity is the full string capacity including null terminator
		inline int capacity() const { return (int)utf16.size(); }

		// the actual length of the string, up to (and not including) the first null-terminator
		int length() const;

		// conversion from UTF-8
		wide_string(std::string_view utf8) { *this = utf8; }
		wide_string(const std::string& utf8) { *this = std::string_view(utf8); }
		wide_string(const char* utf8) { *this = std::string_view(utf8); }

		wide_string& operator=(std::string_view utf8);

#if defined(__cpp_char8_t)
		wide_string(std::u8string_view utf8) { *this = utf8; }
		wide_string(const std::u8string& utf8) { *this = std::u8string_view(utf8); }
		wide_string(const char8_t* utf8) { *this = std::u8string_view(utf8); }

		wide_string& operator=(std::u8string_view utf8)
		{
			return *this = std::string_view((char*)utf8.data(), utf8.size());
		}
#endif

		// conversion to UTF-8
		operator std::string() const { return to_utf8(utf16.data()); }
		static std::string to_utf8(const wchar_t* utf16);

	private:
		std::vector<wchar_t> utf16;
	};


}
