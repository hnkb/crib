
#pragma once

#include "Math"

#include <cstdint>
#include <filesystem>
#include <map>
#include <string>
#include <vector>


namespace crib::Graphics
{

	class Texture
	{};

	// imagine, I have different point types
	// for example


	namespace Constants
	{
		// I can imagine passing nothing as constant data
		// in that case, I draw the 2D points, "as is", to the screen

		namespace PerFrame
		{
			struct DoNothing
			{};

			struct View2D
			{
				float3x3 view;
			};

			struct View3D
			{
				float3x3 view;
			};
		}

		namespace PerObject
		{
			struct Trafo
			{
				float3x3 trafo;  // includes translation, rotation, scaling
								 // includes world * object positioning
			};

			struct TrafoColor  // for points without color
			{
				float3x3 trafo;
				float3x3 color;
			};

			// but, this is not very good usage of buffers, because each character needs separate position/trafo but can be drawn with the same color

			// so, basically, a 2D draw cycle like this:
			//    setColor(xxx)
			//    drawLine(xxx)
			//    drawLine(xxx)
			// ====> oh, for 2D maybe recording a command list is better than creating a scene graph!!!!

			struct ZIndex
			{
				int zIndex;
			};
		}
	}

	namespace Vertex
	{
		// for drawing 2D points

		struct Pos2D
		{
			float2 pos;
		};

		struct Pos2dColor
		{
			float2 pos;
			byte4 color;
		};

		struct Pos2dTex
		{
			float2 pos;
			float2 tex;
		};


		// for 3D we have all these configurations, with optional normal as well

		struct Pos
		{
			float3 pos;
		};

		struct PosColor
		{
			float3 pos;
			byte4 color;
		};

		struct PosTexture
		{
			float3 pos;
			float2 tex;
		};

		struct PosNormal
		{
			float3 pos;
			float3 normal;
		};

		struct PosColorNormal
		{
			float3 pos;
			byte4 color;
			float3 normal;
		};

		struct PosTextureNormal
		{
			float3 pos;
			float2 tex;
			float3 normal;
		};

	}


	struct Pipeline
	{
	public:
	};


	class Context
	{
	public:
		virtual ~Context() {}

		virtual void draw() = 0;
		virtual void onResize(int2 dims) {}

		std::string description;
	};


	class Camera
	{
	public:
		// [world: xyz] <--- camera position and properties --> [view space: xyz]
		//   (in view space: object coordinates are relative to camera not origin)
		// [view space: xyz ] <--- projection ---> [clip space: xy -1...+1]
		//   (clip space is what gets sent to the fragment /pixel shader)
		// [clip space: xy -1...+1] <--- linear ---> [screen space: xy 0..dims]
		//   (for rendering, no need to track this, but to convert screen positions, like when
		//    user clicks, it's useful to be able to convert to/from.)

		void setViewport(int2 dims)
		{
			this->pixelSize = float2(2, -2) / (float2)dims;
			aspectRatio = dims.x / (float)dims.y;
		}

		float2 pixelToClip(float2 pixel) const { return pixel * pixelSize + float2(-1, 1); }
		float2 clipToPixel(float2 clip) const { return (clip - float2(-1, 1)) / pixelSize; }

		// TODO: these will be replaced with transformation matrix for projection + view
		// This is basically the same transformation that happens in shader code (and its
		// inverse)
		float2 worldToClip(float2 world) const { return (world + view.offset) * scaleWithAR(); }
		float2 clipToWorld(float2 clip) const { return clip / scaleWithAR() - view.offset; }

		float2 pixelToWorld(float2 pixel) const { return clipToWorld(pixelToClip(pixel)); }
		float2 worldToPixel(float2 world) const { return clipToPixel(worldToClip(world)); }


		// this can be thought of as our projection for now
		float2 scaleWithAR() const { return { view.scale / aspectRatio, view.scale }; }


		// this is the view transformation
		// should be replaced with a transformation matrix
		struct
		{
			float2 offset = { 0, 0 };  // or translation
			float scale = 1.f;
			// no rotation for now
		} view;

	//private:  (made public for unit tests)
		float2 pixelSize;
		float aspectRatio = 1.f;

	};


	struct ModelPack
	{
		struct
		{
			std::vector<float2> vertex;
			std::vector<uint16_t> index;
		} buffer;

		struct Mesh
		{
			size_t startVertex;
			size_t startIndex;
			size_t indexCount;

			union
			{
				struct
				{
					float advance;
					float lbearing;
				} font;
			};
		};

		std::map<int, Mesh> meshes;
	};

	ModelPack loadMeshFromTTF(const std::filesystem::path&);


	struct Scene
	{
		struct
		{
			std::map<std::string, ModelPack> models;
			// textures, ...
		} assets;

		struct Entity
		{
			int modelId;  // or uint64_t or void*

			// model transformation
			float2 pos;
			// float scale;

			// TODO:
			//  - proper trafo matrix
			//  - hierarchy
			//    - with caching (isDirty)
			//    - with flattening
		};

		std::vector<Entity> entities;
	};

	struct View
	{
		Scene& scene;
		Camera camera;
	};

}
